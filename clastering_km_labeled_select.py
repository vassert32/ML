# -*- coding: utf-8 -*-
"""clastering_km_labeled_select.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iiy2qPg6CHvGWd490mG7bKJimYb-K2jU
"""

# кластеризация k-means с частисно заданной классификацией
import numpy as np
import matplotlib.pyplot as plt

x = [(98, 62), (80, 95), (71, 130), (89, 164), (137, 115), (107, 155), (109, 105), (174, 62), (183, 115), (164, 153),
      (142, 174), (140, 80), (308, 123), (229, 171), (195, 237), (180, 298), (179, 340), (251, 262), (300, 176),
      (346, 178), (311, 237), (291, 283), (254, 340), (215, 308), (239, 223), (281, 207), (283, 156)]
# размеченная часть выборки (первые 15 элементов): соотвественно кластеров будет 2
y = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2])

K = 2   # количество кластеров
X = [list([x[j] for j in range(len(y)) if y[j] == i + 1]) for i in range(K)]    # распределяем заданную выборку
COLORS = ('green', 'purple')

# центры уже размеченных данных
mid = [[] for j in range(K)]

for i in [1, 2]:  # метки кластеров
    cluster_points = np.array([point for point, label in zip(x, y) if label == i])
    mid[i - 1] = np.mean(cluster_points, axis=0)

ro = lambda x_vect, m_vect: np.mean((x_vect - m_vect) ** 2)             # евклидова метрика

# Кластеризация оставшихся данных
for x_vect in x[len(y):]:
    r = [ro(x_vect, m) for m in mid]  # вычисление расстояний для текущего образа до центров кластеров
    X[np.argmin(r)].append(x_vect)    # добавление образа к кластеру с ближайшим центром

# Пересчет центров кластеров
mid = [np.mean(np.array(xx), axis=0) for xx in X]

print("Кластеры:")
for cluster in X:
    print(cluster)

print("\nЦентры кластеров:")
print(mid)

# отображение найденных кластеров
for i in range(K):
    xx = np.array(X[i]).T
    plt.scatter(xx[0], xx[1], s=10, color=COLORS[i])

# отображение центров кластеров
mx = [m[0] for m in mid]
my = [m[1] for m in mid]
plt.scatter(mx, my, s=50, color='red')

plt.show()